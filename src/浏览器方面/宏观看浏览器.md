### 浏览器 

#### 浏览器多进程架构

1. 浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
2. 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。
3. GPU 进程。GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。
4. 主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

#### TCP 协议

1. IP.通过 IP 将数据包放到网络层并加上 IP 头
2. UDP 用户数据包协议 在传输层将 UDP 头以及端口号加上 ，UDP 协议可以校验数据是否正确，但是不能对错误的数据重发。UDP 传输数据速度快，但是不保证数据完整性。
3. TCP 传输控制协议和 UDP 不同的是它还提供了排列的序号，完整的 TCP 链接需要建立连接(三次握手)，传输数据，断开链接(四次挥手)三步

##### 你怎么理解 HTTP 和 TCP 的关系？

HTTP 协议和 TCP 协议都是 TCP/IP 协议簇的字集
HTTP 属于应用层 TCP 属于应用层 HTTP 是 TCP 的上层（OSI 七层模型）
请求方要发送的数据包，在应用层加上 HTTP 头以后会交给传输层的 TCP 协议处理，应答方接收到的数据包，在传输层拆掉 TCP 头以后交给应用层的 HTTP 协议处理。建立 TCP 连接后会顺序收发数据，请求方和应答方都必须依据 HTTP 规范构建和解析 HTTP 报文。

#### HTTP 请求流程

<img src="https://static001.geekbang.org/resource/image/1b/6c/1b49976aca2c700883d48d927f48986c.png" width = "300" height = "200" alt="图片名称" align=center />
构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接。
这里涉及到强缓存和协商缓存(后面详细说)

#### URL 输入到页面展示经历了什么？

##### 用户输入

1. 用户在地址栏按下回车，检查输入（关键字 or 符合 URL 规则），组装完整 URL；
2. 回车前，当前页面执行 onbeforeunload 事件；
3. 浏览器进入加载状态。

##### URL 请求

1. 浏览器进程通过 IPC 把 URL 请求发送至网络进程；
2. 查找资源缓存（有效期内）；
3. DNS 解析（查询 DNS 缓存）；
4. 进入 TCP 队列（单个域名 TCP 连接数量限制）；
5. 创建 TCP 链接（三次握手）；
6. HTTPS 建立 TLS 连接（client hello, server hello, pre-master key 生成『对话密钥』）；
7. 发送 HTTP 请求（请求行[方法、URL、协议]、请求头 Cookie 等、请求体 POST）；
8. 接受请求（响应行[协议、状态码、状态消息]、响应头、响应体等）；
   - 状态码 301 / 302，根据响应头中的 Location 重定向；
   - 状态码 200，根据响应头中的 Content-Type 决定如何响应（下载文件、加载资源、渲染 HTML）。

##### 准备渲染进程

1. 根据是否同一站点（相同的协议和根域名），决定是否复用渲染进程。(必须是在当前页面的基础上再打开新页面)

##### 提交文档

1. 浏览器进程接收到网络进程的响应头数据，向渲染进程发送提交文档的消息；
2. 渲染进程接收到消息后与网络进程建立信息通道
3. 传输完成后，渲染进程返回『确认提交』消息给浏览器进程；
4. 浏览器接受『确认提交』消息后，移除旧文档、更新界面、地址栏，导航历史状态等；
5. 此时标识浏览器加载状态的小圆圈，从此前 URL 网络请求时的逆时针选择，即将变成顺时针旋转（进入渲染阶段）。

##### 渲染

构建 DOM 树 输入 HTML 文档 经过 HTML 解析器处理 输出 DOM 数据结构
样式计算 输入 css 文本 处理每个节点的样式 输出 styleSheets（CSSOM)
布局 根据 DOM&CSSOM 生成渲染树 在生成布局树 最后计算布局
分层

1. 特定节点生成专用图层，生成一棵图层树（层叠上下文、Clip，类似 PhotoShop 里的图层）；
2. 拥有层叠上下文属性（明确定位属性、透明属性、CSS 滤镜、z-index 等）的元素会创建单独图层；
3. 没有图层的 DOM 节点属于父节点图层；
4. 需要剪裁的地方也会创建图层。
   绘制指令
5. 输入：图层树；
6. 渲染引擎对图层树中每个图层进行绘制；
7. 拆分成绘制指令，生成绘制列表，提交到合成线程；
8. 输出：绘制列表。
   分块
9. 合成线程会将较大、较长的图层（一屏显示不完，大部分不在视口内）划分为图块（tile, 256*256, 512*512）。
   光栅化（栅格化）
10. 在光栅化线程池中，将视口附近的图块优先生成位图（栅格化执行该操作）；
11. 快速栅格化：GPU 加速，生成位图（GPU 进程）。
    合成绘制
12. 绘制图块命令——DrawQuad，提交给浏览器进程；
13. 浏览器进程的 viz 组件，根据 DrawQuad 命令，绘制在屏幕上。
